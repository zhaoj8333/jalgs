package phase1.ds.graph;import phase1.ds.uf.generic.UnionFindGeneric2;import java.util.*;public class ListGraph2<V, W> extends Graph<V, W> {    /**     * v与Vertex一一对应     */    private HashMap<V, Vertex<V, W>> vertices = new HashMap<>();    private Set<Edge<V, W>> edges = new HashSet<>();    public ListGraph2(WeightManager<W> weightManager) {        super(weightManager);    }    public ListGraph2() {        super(null);    }    private static class Vertex<V, W> {        V value;        Set<Edge<V, W>> inEdges  = new HashSet<>();        Set<Edge<V, W>> outEdges = new HashSet<>();        public Vertex(V value) {            this.value = value;        }        @Override        public boolean equals(Object o) {            if (this == o) {                return true;            }            if (o == null || getClass() != o.getClass()) {                return false;            }            Vertex<?, ?> vertex = (Vertex<?, ?>) o;            return Objects.equals(value, vertex.value);        }        @Override        public int hashCode() {            return value == null ? 0 : value.hashCode();        }        @Override        public String toString() {            return "" + value;        }    }    private static class Edge<V, W> {        Vertex<V, W> from;        Vertex<V, W> to;        W weight;        public Edge(W weight) {            this.weight = weight;        }        public Edge(Vertex<V, W> from, Vertex<V, W> to) {            this.from = from;            this.to = to;        }        public Edge(Vertex<V, W> from, Vertex<V, W> to, W weight) {            this.from = from;            this.to   = to;            this.weight = weight;        }        public EdgeInfo<V, W> info() {            return new EdgeInfo(from, to, weight);        }        @Override        public boolean equals(Object o) {            if (this == o) {                return true;            }            if (o == null || getClass() != o.getClass()) {                return false;            }            Edge<?, ?> edge = (Edge<?, ?>) o;            return Objects.equals(from, edge.from) && Objects.equals(to, edge.to);        }        @Override        public int hashCode() {            return from.hashCode() * 31 + to.hashCode();        }        @Override        public String toString() {            return "(" + from + " -> " + to + ") " + weight;        }    }    @Override    public int edgesSize() {        return edges.size();    }    @Override    public int vertexSize() {        return vertices.size();    }    @Override    public void addVertex(V v) {        if (vertices.containsKey(v)) {            return;        }        vertices.put(v, new Vertex<>(v));    }    @Override    public void addEdge(V from, V to, W weight) {        Vertex<V, W> fromVertex = vertices.get(from);        if (fromVertex == null) {            fromVertex = new Vertex<>(from);            vertices.put(from, fromVertex);        }        Vertex<V, W> toVertex = vertices.get(to);        if (toVertex == null) {            toVertex = new Vertex<>(to);            vertices.put(to, toVertex);        }        Edge<V, W> newEdge = new Edge<>(fromVertex, toVertex, weight);        if (fromVertex.outEdges.remove(newEdge)) {            toVertex.inEdges.remove(newEdge);            edges.remove(newEdge);        }        fromVertex.outEdges.add(newEdge);        toVertex.inEdges.add(newEdge);        edges.add(newEdge);    }    @Override    public void addEdge(V from, V to) {        addEdge(from, to, null);    }    @Override    public void removeVertex(V v) {        Vertex<V, W> vertexTobeRemoved = vertices.remove(v);        if (vertexTobeRemoved == null) {            return;        }        // 删除vertexTobeRemoved相关的边        // 以vertexTobeRemoved为起点的边        Iterator<Edge<V, W>> itr = vertexTobeRemoved.outEdges.iterator();        for (; itr.hasNext(); ) {            Edge<V, W> edgesFromIt = itr.next();            edgesFromIt.to.inEdges.remove(edgesFromIt);            itr.remove();            edges.remove(edgesFromIt);        }        // 以vertexTobeRemoved为终点的边        itr = vertexTobeRemoved.inEdges.iterator();        for (; itr.hasNext(); ) {            Edge<V, W> edgesToIt = itr.next();            edgesToIt.from.outEdges.remove(edgesToIt);            itr.remove();            edges.remove(edgesToIt);        }    }    @Override    public void removeEdge(V from, V to) {        Vertex<V, W> fromVertex = vertices.get(from);        if (fromVertex == null) {            return;        }        Vertex<V, W> toVertex = vertices.get(to);        if (toVertex == null) {            return;        }        Edge<V, W> edgeTobeRemoved = new Edge<>(fromVertex, toVertex);        if (fromVertex.outEdges.remove(edgeTobeRemoved)) {            toVertex.inEdges.remove(edgeTobeRemoved);            edges.remove(edgeTobeRemoved);        }    }    @Override    public void bfs(V begin, VertexVisitor<V> visitor) {        if (visitor == null) {            return;        }        Vertex<V, W> beginVertex = vertices.get(begin);        if (beginVertex == null) {            return;        }        Queue<Vertex<V, W>> queue = new LinkedList<>();        Set<Vertex<V, W>> visited = new HashSet<>();        queue.offer(beginVertex);        // 已经访问过的顶点在入队的时候添加，否则可能造成 队列重复添加的情况        visited.add(beginVertex);        while (! queue.isEmpty()) {            Vertex<V, W> vertex = queue.poll();            if (visitor.visit(vertex.value)) {                return;            }            for (Edge<V, W> outEdge : vertex.outEdges) {                if (! visited.contains(outEdge.to)) {                    queue.offer(outEdge.to);                    visited.add(outEdge.to);                }            }        }    }    @Override    public void dfs(V begin, VertexVisitor<V> visitor) {        if (visitor == null) {            return;        }        Vertex<V, W> beginVertex = vertices.get(begin);        if (beginVertex == null) {            return;        }        dfs(beginVertex, visitor, new HashSet<>());        System.out.println("xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx");        dfsByStack(beginVertex, visitor, new HashSet<>());    }    private void dfsByStack(Vertex<V, W> beginVertex, VertexVisitor<V> visitor, Set<Vertex<V, W>> visited) {        Stack<Vertex<V, W>> stack = new Stack<>();        stack.push(beginVertex);        visited.add(beginVertex);        if (visitor.visit(beginVertex.value)) {            return;        }        while (! stack.isEmpty()) {            Vertex<V, W> vertex = stack.pop();            for (Edge<V, W> edge : vertex.outEdges) {                if (visited.contains(edge.to)) {                    continue;                }                stack.push(edge.from);                stack.push(edge.to);                if (visitor.visit(edge.to.value)) {                    return;                }                visited.add(edge.to);                break;            }        }    }    private void dfs(Vertex<V, W> vertex, VertexVisitor<V> visitor, Set<Vertex<V, W>> visited) {        visited.add(vertex);        if (visitor.visit(vertex.value)) {            return;        }        for (Edge<V, W> edge : vertex.outEdges) {            if (visited.contains(edge.to)) {                continue;            }            dfs(edge.to, visitor, visited);        }    }    @Override    public Set<EdgeInfo<V, W>> mst(boolean prim) {        System.out.println("mstmstmstmstmstmstmstmstmstmstmstmstmstmst");        if (prim) {            return prim();        } else {            return kruskal();        }    }    private Comparator<Edge<V, W>> edgeComparator = (Edge<V, W> a, Edge<V, W> b)            -> weightManager.compare(b.weight, a.weight);    private Set<EdgeInfo<V ,W>> prim() {        Iterator<Vertex<V, W>> itr = vertices.values().iterator();        if (! itr.hasNext()) {            return null;        }        Set<EdgeInfo<V, W>> mst = new HashSet<>();        Set<Vertex<V, W>> added = new HashSet<>();        Vertex<V, W> vertex = itr.next();        added.add(vertex);        MinHeap<Edge<V, W>> heap = new MinHeap<>(vertex.outEdges, edgeComparator);        int edgeSize = vertices.size() - 1;        // 连通图的极小联通子图，含有图中全部的 n 个顶点，恰好只有 n-1 条边        while (! heap.isEmpty() && mst.size() < edgeSize) {            Edge<V, W> edge = heap.remove();            if (added.contains(edge.to)) {                continue;            }            mst.add(edge.info());            added.add(edge.to);            heap.addAll(edge.to.outEdges);        }        // System.out.println(added.size() + "  " + vertices.size());        return mst;    }    private Set<EdgeInfo<V, W>> kruskal() {        if (vertices.size() == 0) {            return null;        }        UnionFindGeneric2<Vertex<V, W>> uf = new UnionFindGeneric2<>();        vertices.forEach((V key, Vertex<V, W> vertex) -> {            uf.add(vertex);        });        Set<EdgeInfo<V, W>> mst  = new HashSet<>();        MinHeap<Edge<V, W>> heap = new MinHeap<>(edges, edgeComparator);        int edgeSize = vertices.size() - 1;        while (! heap.isEmpty() && mst.size() < edgeSize) {            Edge<V, W> edge = heap.remove();            if (uf.isSame(edge.from, edge.to)) {                continue;            }            mst.add(edge.info());            uf.union(edge.from, edge.to);        }        return mst;    }    @Override    public Set<EdgeInfo<Object, Double>> print() {        System.out.print("vertices: ");        vertices.forEach((V key, Vertex<V, W> vertex) -> {            System.out.print(key + " ");        });        System.out.println();        System.out.println();        System.out.println("edges: ");        edges.forEach(System.out::println);        return null;    }    /**     * 卡恩算法 kahn     */    @Override    public List<V> topoSort() {        List<V> list = new ArrayList<>();        Queue<Vertex<V, W>> q = new LinkedList<>();        Map<Vertex<V, W>, Integer> inDegrees = new HashMap<>();        vertices.forEach((V v, Vertex<V, W> vertex) -> {            int inCount = vertex.inEdges.size();            if (inCount == 0) {                q.offer(vertex);            } else {                inDegrees.put(vertex, inCount);            }        });        while (! q.isEmpty()) {            Vertex<V, W> vertex = q.poll();            list.add(vertex.value);            for (Edge<V, W> edge : vertex.outEdges) {                Vertex<V, W> vert = edge.to;                int inDegree = inDegrees.get(vert) - 1;                if (inDegree == 0) {                    q.offer(vert);                } else {                    inDegrees.put(vert, inDegree);                }            }        }        return list;    }    @Override    public Map<V, W> dijkstra1(V begin) {        return null;    }    @Override    public Map<V, PathInfo<V, W>> dijkstra2(V begin) {        return null;    }    @Override    public Map<V, PathInfo<V, W>> bellmanFord(V begin) {        return null;    }    @Override    public Map<V, Map<V, PathInfo<V, W>>> floyd() {        return null;    }}
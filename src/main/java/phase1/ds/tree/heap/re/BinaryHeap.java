package phase1.ds.tree.heap.re;import phase1.ds.tree.heap.Heap;import phase1.ds.tree.printer.BinaryTreeInfo;import java.util.Arrays;import java.util.Comparator;import java.util.Objects;/** * 如果任意节点的值总是 >= 子节点的值，成为最大堆, 但是不一定就是任意的上一层的值就比下一层的大 * * 二叉堆的逻辑就是一棵完全二叉树，所以也叫完全二叉堆，底层用数组实现 */public class BinaryHeap<E> implements Heap, BinaryTreeInfo {    private E[] elements;    private int size;    private Comparator<E> comparator;    private static final int DEFAULT_CAPACITY = 10;    public BinaryHeap(Comparator<E> comparator) {        this.comparator = comparator;        this.elements = (E[]) new Object[DEFAULT_CAPACITY];    }    public BinaryHeap(E[] elements, Comparator<E> comparator) {        this.comparator = comparator;        if (Objects.nonNull(elements) && elements.length > 0) {            size = elements.length;            int capacity = Math.max(elements.length, DEFAULT_CAPACITY);            this.elements = (E[]) new Object[capacity];            System.arraycopy(elements, 0, this.elements, 0, size);            heapify();        } else {            this.elements = (E[]) new Object[DEFAULT_CAPACITY];        }    }    public BinaryHeap() {        this(null, null);    }    public E[] getElements() {        return elements;    }    private int compare(E a, E b) {        return Objects.nonNull(comparator) ? comparator.compare(a, b) : ((Comparable<E>) a).compareTo(b);    }    @Override    public int size() {        return size;    }    @Override    public boolean isEmpty() {        return size == 0;    }    @Override    public void add(Object element) {        Objects.requireNonNull(element);        ensureCapacity(size + 1);        // 只有从最后添加才符合完全二叉树的性质        elements[size++] = (E) element;        shiftUp(size - 1);    }    /**     * 每次添加的元素都是在数组的最后一个元素，防止因添加导致的内存整理过程     */    private void shiftUp(int index) {        E newChild = elements[index];        while (index > 0) {            int parentIndex = (index - 1) >> 1;            E parent = elements[parentIndex];            if (compare(newChild, parent) <= 0) break;            elements[index] = parent;            index = parentIndex;        }        elements[index] = newChild;    }    private void ensureCapacity(int capacity) {        int oldCapacity = elements.length;        if (oldCapacity >= capacity) {            return;        }        int newCapacity = oldCapacity + (oldCapacity >> 1);        E[] newElements = (E[]) new Object[newCapacity];        if (size >= 0) System.arraycopy(elements, 0, newElements, 0, size);        elements = newElements;    }    /**     * 获得堆顶元素     *     * @return 堆顶元素     */    @Override    public E get() {        checkEmpty();        return elements[0];    }    private void checkEmpty() {        if (isEmpty()) throw new ArrayIndexOutOfBoundsException("elements can't be empty");    }    /**     * 如果按照正常的数组的删除逻辑的话，由于内存管理，可能会导致删除的复杂度增加     */    @Override    public E remove() {        checkEmpty();        E root = elements[0];        int lastIndex = --size;        elements[0] = elements[lastIndex];        elements[lastIndex] = null;        siftDown(0);        return root;    }    private void siftDown(int index) {        E parent = elements[index];        int half  = size >> 1;        // index必须是有子节点的, 也就是index位置的元素可以下虑        // 第一个叶子节点的数量 == 非叶子节点的数量        while (index < half) {            int childIndex = (index << 1) + 1;            E child = elements[childIndex];            int rightIndex = childIndex + 1;            if (compare(elements[rightIndex], child) > 0) {                child = elements[childIndex = rightIndex];            }            if (compare(parent, child) >= 0) break;            elements[index] = child;            index = childIndex;        }        elements[index] = parent;    }    /**     * 替换堆顶元素     */    @Override    public E replace(Object element) {        Objects.requireNonNull(element);        E root = null;        if (size == 0) {            elements[size++] = (E) element;        } else {            root = elements[0];            elements[0] = (E) element;            siftDown(0);        }        return root;    }    @Override    public void clear() {        Arrays.fill(elements, null);        size = 0;    }    /**     * 批量建堆     * <code>     *     for (int i = 0; i < array.length; i++) {     *         heap.add(array[i]);     *     }     * </code>     *     * 批量建堆可以通过添加，但是批量建堆效率更高     *     * 批量建堆：     *     自上而下的上滤：本质就是添加     *     自下而上的下虑：本质就是让左右都变成堆，组后左后堆合并变成最大堆，原理类似于删除     *     * 自下而上的下虑     */    @Override    public void heapify() {//        for (int i = 1; i < elements.length; i++) {//            siftUp(i);//        }        for (int i = (size >> 1) - 1; i >= 0; i--) {            siftDown(i);        }    }    private void siftUp(int i) {    }    @Override    public Object root() {        return 0;    }    @Override    public Object left(Object node) {        Integer index = (Integer) node;        index = (index << 1) + 1;        return index >= size ? null : index;    }    @Override    public Object right(Object node) {        Integer index = (Integer) node;        index = (index << 1) + 2;        return index >= size ? null : index;    }    @Override    public Object string(Object node) {        Integer index = (Integer) node;        return elements[index];    }}
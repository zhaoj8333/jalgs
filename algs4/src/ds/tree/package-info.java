/*
    节点、根节点、父节点、子节点、兄弟节点

    空树

    子树、 左子树、 右子树

    节点的度： 子树的个数
    树的度：所有节点度中的最大值

    叶子节点：度为0的节点
    非叶子节点：

    层数：

    节点深度：根节点到当前节点的唯一路径上的节点总数
    节点高度：从当前节点到最远叶子节点的路径上的节点总数

    树的深度：所有节点深度最大值
    树的高度：所有节点高度最大值
    树的深度与高度相同

    有序树：树中任意子节点之间有顺序关系
    无序树（自由树）

    森林：m棵不相交的树组成的集合

    二叉树：
        每个节点度最大为2： 0 1 2三种情况
        左子树右子树有顺序
        即使只有一棵树，也要区分左右子树

    二叉树是有序树

    性质：
        叶子节点个数：n0
        度为1的节点个数：n1
        度为2的节点个数：n2
        总结点个数：n = n0 + n1 + n2

        二叉树的边数：
            T = n1 + 2 * n2 = n - 1 = n0 + n1 + n2 - 1
            n2 = n0 - 1
        边数 = 度数

        整个树，除了根节点顶部没有没有边，所以 T = n - 1

        对于任何非空二叉树，如果叶子节点个数为n0，度为2的节点个数为n2，则有: n0 = n2 + 1

        非空二叉树的第i层，最多有2^(i-1)个节点(i >= 1)
        高度为h的二叉树上最多有2^(h) - 1个节点(h >= 1)

    真二叉树：
        所有节点度要么为0，要么为2(节点要么而0个子节点，要么就有2个子节点)
    满二叉树：
        所有节点度要么为0，要么为2，且所有叶子节点都在最后一层(度为0的节点都在最后一层)，在同样高度的二叉树中，
        满二叉树叶子节点数量最多，总结点数量最多
        满二叉树一定是真二叉树，真二叉树不一定是满二叉树

        第i层节点数为 2^(i-1)
        第i层节点数为2^i
        总节点个数为 2^i - 1
        高度h = log2(n + 1)

     完全二叉树： 满二叉树对应
        叶子节点只会出现在最后两层，且最后一层的叶子节点都靠左对齐
        节点排布为从上到下，从左到右
        完全二叉树从根节点至倒数第二层是一颗满二叉树
        满二叉树一定是完全二叉树,完全二叉树不一定是满二叉树

        性质：
            度为1的节点只有左子树（靠左对齐）
            度为1的节点数量要么为1，要么为0
            同样节点的二叉树，完全二叉树的高度最小

            高度为h，则至少有2^(h - 1)个节点，最多有2^h - 1个节点(满二叉树)
            总结点数为n， 2^(h-1) <= n <= 2^(h-1)
                        2^(h-1) <= n < 2^h
                        h - 1 <= log2(n) < h
            高度h =  Math.ceil(log2(n))

            完全二叉树，从上到下，从左到右从0开始编号，对任意第i个节点，如果
            i = 0,为根节点
            i > 0，父节点编号为floor((i - 1) / 2)
            如果 2i + 1 <= n - 1，左子节点编号为2i + 1
            2i + 1 > n - 1,没有左子节点
            2i + 2 <= n - 1，右子节点编号为2i + 2

        已知节点总数，叶子节点个数为：
            (n + 1) >> 1

    线性数据结构的遍历：
        正序遍历
        逆序遍历
    树结构遍历：
        前序遍历
        中序遍历
        后序遍历
        层序遍历


    平衡： 当节点数量固定时，左右子树的高度越接近，这棵树就月平衡，高度就越低
    理想平衡：像完全二叉树，满二叉树那样，高度最小
    改进二叉树：
        1. 节点的添加、 删除顺序是无法限制的，可以认为是随机的
        2. 改进方案是，在节点的添加、删除后，让二叉搜索树恢复平衡（减小树的高度）
        3. 打到理想平衡，代价可能会比较大
        所以，比较合理的方案是，用尽量少的调整次数打到适度平衡即可
    常见平衡二叉树：
        AVL树： windows nt内核广泛使用
        红黑树：c++ STL库(map,ds.set)
        java： TreeMap, TreeSet, HashMap, HashSet
        Linux进程调度
        nginx的timer管理
    自平衡的二叉搜索树

    AVL树：
        平衡因子：(Balance Factor)，某个节点的左右子树的高度差
        特点： 每个节点的平衡因子只可能是1、 0 、 -1，绝对值<= 1，否则称为失衡
        左右子树高度差不超过1
        搜索，添加，删除的时间复杂度为logn

        添加导致的失衡：
        最坏情况：可能导致所有的祖父节点都失衡，父节点、 非祖先节点不会失衡
            1. LL - 右旋转（单旋）： left-left
            2. RR - 左旋转（单旋）：
            3. LR - RR左旋转，LL右旋转(双旋)
            4. RL - LL右旋转，RR左旋转

    Red-Black tree： 红黑树也是一种自平衡的二叉搜索树，也叫平衡二叉B树
        1. 节点是red或black
        2. 根节点是black
        3. 叶子节点: 红黑树的叶子节点都是null节点，度要么为0，要么为2，使得红黑树称为 真二叉树
           都是black（叶子节点： 外部节点、 空节点） 红黑树会让原度为1，度为0的节点变为度为2的节点(通过增加null)
           所有节点度都是2
        4. 红节点的子节点都是black: (黑节点的子节点不一定是红节点，也会是黑节点)
            red节点parent都是black
            从根节点到叶子节点的所有路径上不能有两个连续的red节点
        5. 从任一节点到叶子节点的所有路径都包含相同数目的black节点
           >>> 黑色节点完美平衡 <<<
        在以上性质之下，就能保证红黑树的平衡 ??????

    Btree: B树是一种平衡的多路搜索树，多用于文件系统 ，数据库的实现
        B树（b-tree）
        3阶B树、 4阶B树、 5阶B树

        1. 一个节点可以存储超过两个元素或节点
        2. 拥有二叉树的一些性质
        3. 每个节点的所有字子树高度一致
        4. 高度非常矮

        m阶b树的性质(m阶树的定义)： 假设一个节点元素个数为 x
            1. 根节点： 1 <= x <= m - 1
            2. 非根节点： ceil(m/2) - 1 <= x <= m - 1
                如果有子节点： y = x + 1
                则根节点： ceil(m/2) <= y <= m
                非根节点： ceil(m/2) <= y <= m
               > m = 3, 2 <= y <= 3,则（2,3）树，2-3树
               > m = 4, 2-3-4树
               > m = 5, 3-4-5树
               > m = 6, 3-6树
               > m = 7, 4-7树

               数据库一般使用200-300阶树

        b树 与 二叉树
            b树与二叉树逻辑上等价
            多代节点合并，可以获得一个超级节点
                两代合并的超级节点，最多拥有4个子节点（至少是4阶b树）
                三代合并的超级节点，最多拥有8个子节点（至少是8阶b树）
                n代合并的超级节点，最多拥有2^n个子节点（至少是2^n阶b树）
                m阶b树，最多需要log2m代合并
                m阶b树，最多有m-1个节点
            搜索：
            1. 先在节点内部从小到大开始搜索元素，命中搜索结束，未命中，再去对应的子节点搜索,重复
            m阶B树的性质(m >= 2)： m阶（一个非叶子节点最多拥有m - 1个节点）

            添加：
            1. 新添加的元素必定是添加到叶子节点
            2. 如果添加后节点的元素个数超过上限，则需要进行上溢
            3. 所有的叶子节点都在同一层

            上溢：
            1. 上溢节点的元素个数必然等于 m
            2. 假设上溢节点最中间的元素的位置为k，将k位置的元素向上与父节点合并
               将[0, k - 1]和[k + 1, m - 1]位置的元素分裂成2个z节点
               一次分裂完毕，有可能给导致父节点上溢，则重复进行，有可能导致分裂到根节点，此种情况是唯一的导致树高增加的情况

            删除：
            1. 叶子节点：   直接删除即可
                叶子节点被删除，元素个数肯能会低于最低限制( >= ceil(m/2) - 1)
                下溢节点的元素数量必然等于 (m/2)/2
                如果下溢节点临近的兄弟节点，有至少 ceil(m/2)个元素，可以向其借一个元素
                将父节点的元素b插入到下溢节点的0位置
                将兄弟节点的最大元素a替代父节点的元素b
                (旋转)
                如果下溢节点临近的兄弟节点只有ceil(m/2)-1个元素,则将父节点的元素b挪下来跟左右子节点进行合并
                合并之后的元素个数为ceil(m/2) + ceil(m/2) - 2,不超过 m-1
                该操作可能导致父节点下溢，依然一次以此方式解决，下溢一直到根节点时，导致树高度变低

            2. 非叶子节点： 找到前驱或后继元素覆盖所需删除的元素的值（非叶子节点的前驱或后继元素，必定在叶子节点中）
               删除的元素必然在叶子节点中


        红黑树与b树（2-3-4树）逻辑上具有等价性：
        black节点与red子节点融合在一起，形成一个b树节点
        红黑树中 black节点个数 与 4阶b树的 节点总个数 相等
        把2-3树与红黑树进行类比是极其不严谨的

        红黑树 与 2-3-4树:
        1. 红黑红
        2. 黑红
        3. 红黑
        4. 黑

    二叉树的问题：
        1. 二叉树需要加载到内存，如果节点很多，构建二叉树需要多次io操作
        2. 海量节点，二叉树高度很大，降低操作速度

    BTree - 多路查找树: 如果允许每个节点可以有更多的数据项和更多子节点，就是多叉树
        1. b树通过重新组织节点，降低树的高度，减少io操作提升效率
        2. fs和db系统利用磁盘预读原理，将一个节点的大小设置为等于一个页（一般为4k），这样每个节点只需要一次io就可以完全载入
        3. 假设树的度M设置为1024，在600亿个元素中最多只需要4次io就可以读取到想要的元素，b+树广泛应用于db和fs
        4. 2-3树： 2节点要么没有子节点，要么有两个子节点
                  3节点要么没有子节点，要么有三个子节点
                  以上性质不满足时，需要上溢下溢
   B-tree:
        1. 2-3树也是一种b树
        2. B树的阶： 节点最多子节点个数
           B-树的搜索：从根节点开始，对节点内的关键字进行二分查找，命中则结束，否则进入查找关键字所属范围的儿子节点，重复直到对应儿子节点为空
           关键字集合分布在整棵树中，即叶子节点和非叶子节点都存放数据，搜索可能就在非叶子节点结束
           搜索性能等价于在关键字全集内做一次二分查找
   B+tree：B树的变体
        1. b+树只有到达叶子节点才命中，性能等价于在关键字全集做一次二分查找
        2. 所有关键字都出现在叶子节点的链表中，数据只在叶子节点（稠密索引），链表中的关键字是有序的
        3. 不可能在非叶子节点命中
        4. 非叶子节点相当于叶子节点的索引（稀疏索引），叶子节点相当于存储数据的数据层
        5. 更适合文件系统
        6. b树和b+树有自己的应用场景
   B*树：B+树的变体，在B+树的非根和非叶子节点再增加指向兄弟的指针
        B*树定义了非叶子节点关键字个数至少为(2/3)*m，即块的最低使用率为2/3，而B+树的最低使用率为1/2
        B+树分配新节点的概率比b+树要低，空间使用率更高

   表达式树:
        前缀表达式： 波兰表达式
        中缀表达式
        后缀表达之： 逆波兰表达式


 */